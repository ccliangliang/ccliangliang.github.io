<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>C++ container | Misakas</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="C++ STL容器整理在数据存储上，有一种对象类型，它可以持有其它对象或指向其它对像的指针，这种对象类型就叫做容器。很简单，容器就是保存其它对象的对象，当然这是一个朴素的理解，这种“对象”还包含了一系列处理“其它对象”的方法。">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ container">
<meta property="og:url" content="https://ccliangliang.github.io/2020/02/25/C++%20container/index.html">
<meta property="og:site_name" content="Misakas">
<meta property="og:description" content="C++ STL容器整理在数据存储上，有一种对象类型，它可以持有其它对象或指向其它对像的指针，这种对象类型就叫做容器。很简单，容器就是保存其它对象的对象，当然这是一个朴素的理解，这种“对象”还包含了一系列处理“其它对象”的方法。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-02-25T01:58:01.000Z">
<meta property="article:modified_time" content="2020-02-27T14:23:12.607Z">
<meta property="article:author" content="Misakas">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="STL">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Misakas" type="application/atom+xml">
  
  
    <link rel="icon" href="/images/favicon.ico">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/plugin/bganimation/bg.css">

  

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <div class="outer">
        <div class="widget-wrap mobile-header">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1582606800301&amp;di=836da10f5415c3117c4449e1b4e818d2&amp;imgtype=0&amp;src=http%3A%2F%2Fimg.qqzhi.com%2Fuploads%2F2018-12-22%2F094255544.jpg">
    <h2 class="author">Misakas</h2>
    <h3 class="description"></h3>
    <div class="count-box">
      <a href="/archives"><div><strong>4</strong><br>文章</div></a>
      <a href="/categories"><div><strong>2</strong><br>分类</div></a>
      <a href="/tags"><div><strong>4</strong><br>标签</div></a>
    </div>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/categories" title="Categories">
            <li>分类</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>标签</li>
          </a>
        
    </ul>
  </div>
</div>

        <section id="main"><article id="post-C++ container" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/25/C++%20container/" class="article-date">
  <time class="post-time" datetime="2020-02-25T01:58:01.000Z" itemprop="datePublished">
    <span class="post-month">2月</span><br/>
    <span class="post-day">25</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      C++ container
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/C/">C++</a>
  </div>

          
              
  &nbsp; | &nbsp;
  <div class="view-box">
    <span id="/2020/02/25/C++%20container/" class="leancloud_visitors" data-flag-title="C++ container">
      &nbsp;阅读次数<span class="leancloud-visitors-count"></span>
    </span>
  </div>


          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="C-STL容器整理"><a href="#C-STL容器整理" class="headerlink" title="C++ STL容器整理"></a>C++ STL容器整理</h2><p>在数据存储上，有一种对象类型，它可以持有其它对象或指向其它对像的指针，这种对象类型就叫做容器。很简单，容器就是保存其它对象的对象，当然这是一个朴素的理解，这种“对象”还包含了一系列处理“其它对象”的方法。</p>
<a id="more"></a>

<p> <font color = red size = 6>序列式容器</font></p>
<p> <font color = red size = 4>vector的用法</font><br>vector是向量类型，它可以容纳许多类型的数据，如若干个整数，所以称其为容器。vector是C++STL的一个重要成员，使用它时需要包含<a href="https://baike.baidu.com/item/%E5%A4%B4%E6%96%87%E4%BB%B6/10978258?fr=aladdin" target="_blank" rel="noopener">头文件：</a><br><code>#include &lt; vector &gt;</code></p>
<p>一、vector（向量）类模板<br>vector是定义于名称空间（namespace）std内的模板。<br>其原型为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Allocator</span> = <span class="title">allocator</span>&lt;T&gt;&gt; <span class="title">class</span> <span class="title">vector</span>;</span></span><br></pre></td></tr></table></figure>
<p><strong>vector的迭代器是随机存取迭代器，对任何一个STL算法均奏效。</strong> 尤其在容器末端或删除元素时，vector性能相当好。</p>
<p>二、vector的初始化：可以有五种方式，举例如下：<br>    （1） <code>vector&lt; int&gt; a(10);</code> //定义了10个整形元素的向量 (尖括号中为元素类型名，它可以是任何合法的数据类型)， 但没有给出初值，其初值是垃圾值。<br>    （2）<code>vector&lt; int&gt; a(10, 1);</code>//定义了10个整形元素的向量，且给出每个元素的初值为1<br>    （3）<code>vector&lt; int&gt; a(b);</code> //用b向量来创建a向量，整体复制性赋值<br>    （4）<code>vector&lt; int&gt; a(b.begin(), b.begin + 3);</code> //定义了a值为b中第0个到第2个(共3个)元素<br>    （5）<code>int b[7] = {1, 2, 3, 4, 5, 9, 8};</code><br>    　　      　<code>vector&lt; int&gt; a(b, b + 7);</code>//从数组中获得初值</p>
<p>三、vector的基本应用函数<br>（1）<code>a.assign(b.begin(), b.begin()+3);</code>//b为向量，将b的0~2个元素构成的向量赋给a<br>    （2）<code>a.assign(4,2);</code> //a只含4个元素，且每个元素为2<br>    （3）<code>a.back();</code> //返回a的最后一个元素<br>    （4）<code>a.front();</code> //返回a的第一个元素<br>    （5）<code>a[i];</code> //返回a的第i个元素，当且仅当a[i]存在<br>    （6）<code>a.clear();</code> //清空a中的元素<br>    （7）<code>a.empty();</code>//判断a是否为空，空则返回ture,不空则返回false<br>    （8）<code>a.pop_back();</code>//删除a向量的最后一个元素<br>    （9）<code>a.erase(a.begin()+1,a.begin()+3);</code> //删除a中第1个 (从第0个算起) 到第2个元素，也就是说删除的元素从a.begin()+1算起（包括它）一直到a.begin()+ 3(不包括它）<br>    （10）<code>a.push_back(5);</code> //在a的最后一个向量后插入一个元素，其值为5<br>    （11）<code>a.insert(a.begin()+1,5);</code>//在a的第1个元素（从第0个算起）的位置插入数值5，如a为1,2,3,4，插入元素后为1,5,2,3,4<br>    （12）<code>a.insert(a.begin()+1,3,5);</code>//在a的第1个元素（从第0个算起）的位置插入3个数，其值都为5,如a为1,2,3, 插入后元素为1,5,5,5,2,3<br>    （13）<code>a.insert(a.begin()+1,b+3,b+6);</code> //b为数组，在a的第1个元素（从第0个算起）的位置插入b的第3个元素到第5个元素（不包括b+6），如a为1, 2, 3,b为1,2,3,4,5,6,7，插入元素后为1,4,5,6,2,3<br>    （14）<code>a.size();</code> //返回a中元素的个数；<br>    （15）<code>a.capacity();</code>//返回a在内存中总共可以容纳的元素个数<br>    （16）<code>a.resize(10);</code> //将a的现有元素个数调至10个，多则删，少则补，其值随机<br>    （17）<code>a.resize(10,2);</code> //将a的现有元素个数调至10个，多则删，少则补，其值为2<br>    （18）<code>a.reserve(100);</code>//将a的容量（capacity）扩充至100，也就是说现在测试a.capacity();的时候返回值是100.这种操作只有在需要给a添加大量数据的时候才         显得有意义，因为这将避免内存多次容量扩充操作（当a的容量不足时电脑会自动扩容，当然这必然降低性能）<br>    （19）<code>a.swap(b);</code> //b为向量，将a中的元素和b中的元素进行整体性交换<br>    （20）<code>a==b;</code> //b为向量，向量的比较操作还有!=,&gt;=,&lt;=,&gt;,&lt;</p>
<p>四、顺序访问vector的几种方式<br>（1）向向量a中添加元素<br>1、</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	a.push_back(i);</span><br></pre></td></tr></table></figure>
<p>2、也可以从数组中选择元素向向量中添加</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">6</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt;= <span class="number">4</span>; i++)</span><br><span class="line">	b.push_back(a[i]);</span><br></pre></td></tr></table></figure>
<p>3、也可以从现有向量中选择元素向向量中添加</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">6</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">c</span><span class="params">(a, a + <span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = c.<span class="built_in">begin</span>(); it != c.<span class="built_in">end</span>(); it++)</span><br><span class="line">	b.push_back(*it);</span><br></pre></td></tr></table></figure>
<p>4、<font color = "red">[误区]</font></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	a[i] = i;</span><br></pre></td></tr></table></figure>
<p><font color = "red">//这中做法以及类似的做法都是错误的。下标只能用于获取已存在的元素，而现在的a[i]还是空的对象</font><br>（2）从向量中读取元素<br>1、通过下标方式读取</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">6</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span> &gt; <span class="title">b</span><span class="params">(a, a + <span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; b[i] &lt;&lt; <span class="string">" "</span>;</span><br></pre></td></tr></table></figure>
<p>2、通过遍历器方式读取</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">6</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span> &gt; <span class="title">b</span><span class="params">(a, a + <span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = b.<span class="built_in">begin</span>(); it != b.<span class="built_in">end</span>(); it++)</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br></pre></td></tr></table></figure>
<p>五、几种重要的算法，使用时需要包含头文件：<br><code>#include &lt; algorithm&gt;</code><br>（1）sort(a.begin(),a.end()); //对a中的从a. begin(包括它）到a.end()（不包括它）的元素进行从小到大排列<br>（2）reverse(a.begin(),a.end()); //对a中的从a. begin()（包括它）到a.end()（不包括它）的元素倒置，但不排列，如a中元素为1,3,2,4,倒置后为4,2,3,1<br>（3）copy(a.begin(),a.end(),b.begin()+1); //把a中的从a. begin()（包括它）到a.end()（不包括它）的元素复制到b中，从b.begin()+1的位置（包括它）开始复制，覆盖掉原有元素<br>（4）find(a.begin(),a.end(),10); //在a中的从a. begin()（包括它）到a.end()（不包括它）的元素中查找10，若存在返回其在向量中的位置</p>
<p><font color = red size = 4>list的用法</font><br>List将元素按顺序储存在链表中，与向量(vector)相比，它允许快速的插入和删除，但是随机访问却比较慢<br>使用它时需要包含<a href="https://baike.baidu.com/item/list/4825101" target="_blank" rel="noopener">list头文件：</a><br><code>#include &lt; list&gt;</code><br>一、list是定义于名称空间（namespace）std内的模板。<br>其原型为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Allocator</span> = <span class="title">allocator</span>&lt;T&gt;&gt; <span class="title">class</span> <span class="title">list</span>;</span></span><br></pre></td></tr></table></figure>
<p>二、list的初始化：可以有五种方式，举例如下：<br>（1）<code>list &lt;int&gt; listname;</code>//定义了一个list对象（尖括号中为元素类型名，它可以是任何合法的数据类型），但没有给出初值。<br>（2）<code>list &lt;int&gt; listname(size);</code>//创建了一个初始大小为size的list对象，没初始值。<br>（3）<code>list &lt;int&gt; listname(size, value);</code>//创建了一个初始大小为size，每个元素的初始值为value的对象。<br>（4）<code>list &lt;int&gt; listnames(elselist);</code> //利用复制构造函数从现有的list中创建新的list对象。<br>（5）<code>list &lt;int&gt; listname(first, last);</code>//创建1个list对象，并从其他list对象中复制由迭代器指定范围的多个元素。</p>
<p>三、list的基本应用函数<br>（1）<code>a.assign();</code> //给list赋值<br>（2）<code>a.back() ;</code>//返回最后一个元素<br>（3）<code>a.begin();</code> //返回指向第一个元素的迭代器<br>（4）<code>a.clear();</code>// 删除所有元素<br>（5）<code>a.empty();</code> //如果list是空的则返回true<br>（6）<code>a.end();</code> //返回末尾的迭代器<br>（7）<code>a.erase();</code>//删除一个元素<br>（8）<code>a.front();</code> //返回第一个元素<br>（9）<code>a.insert();</code>//插入一个元素到list中<br>（10）<code>a.max_size();</code> //返回list能容纳的最大元素数量<br>（11）<code>a.merge(b);</code>//合并两个list<br>（12）<code>a.pop_back();</code> //删除最后一个元素<br>（13）<code>a.pop_front();</code>//删除第一个元素<br>（14）<code>a.push_back();</code> //在list的末尾添加一个元素<br>（15）<code>a.push_front();</code>//在list的头部添加一个元素<br>（16）<code>a.rbegin();</code>//返回指向第一个元素的逆向迭代器<br>（17）<code>a.remove(begin, end, value);</code> //删除begin开始到end中所有与value相等的元素<br>（18）<code>a.remove_if(begin, end, cmp);</code> //删除begin开始到end中所有满足条件的元素<br>（19）<code>a.rend();</code> //指向list末尾的逆向迭代器<br>（20）<code>a.resize();</code> //改变list的大小<br>（21）<code>a.reverse();</code> //把list的元素倒转<br>（22）<code>a.size();</code>//返回list中的元素个数<br>（23）<code>a.sort();</code>//给list排序<br>（24）<code>a.splice(b);</code>//合并两个list<br>（25）<code>a.splice(b,iterator first);</code>//将b中的某个元素（first指向的元素）插入it的后面<br>（26）<code>a.splice(b, begin, end);</code>//将b中某个范围（begin，end）内的元素插入在it后面。<br>（25）<code>swap(a, b);</code>//交换两个list<br>（26）<code>a.unique();</code> //删除list中重复的元素</p>
<p>四、list的几种访问方式<br>（1）、向list中添加元素<br>1、向list头部插入新元素</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> &lt;<span class="keyword">int</span>&gt; listnames;</span><br><span class="line">listname.push_front(a);<span class="comment">//在容器中的头部插入新元素a</span></span><br></pre></td></tr></table></figure>
<p>2、向list尾部插入新元素</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> &lt;<span class="keyword">int</span>&gt; listname;</span><br><span class="line">listname.push_back(a); <span class="comment">//在容器中的尾部插入新元素a</span></span><br></pre></td></tr></table></figure>
<p>（2）、删除list中的元素<br>1、删除list头部的元素</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> &lt;<span class="keyword">int</span>&gt; listnames;</span><br><span class="line">listname.push_front(a);</span><br><span class="line">listname.push_front(b);</span><br><span class="line">listname.push_front(c);</span><br><span class="line">listname.pop_front(d);<span class="comment">//将头部的元素返回至d，并删除头部元素</span></span><br></pre></td></tr></table></figure>
<p>2、删除list尾部的元素</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> &lt;<span class="keyword">int</span>&gt; listnames;</span><br><span class="line">listname.push_front(a);</span><br><span class="line">listname.push_front(b);</span><br><span class="line">listname.push_front(c);</span><br><span class="line">listname.pop_back(d);<span class="comment">//将尾部的元素返回至d，并删除尾部元素</span></span><br></pre></td></tr></table></figure>
<p><font color = red size = 4>deque(双端队列)的用法</font><br>deque模板类提供了对序列随机访问的功能，可以实现在序列两端快速插入和删除操作的功能，在需要时修改自身大小。deque可以完成标准C++数据结构中队列的所有功能。<br>使用它时需要包含<a href="https://baike.baidu.com/item/deque/849385?fr=aladdin" target="_blank" rel="noopener">deque头文件：</a><br><code>#include &lt;deque&gt;</code><br>一、头文件中，deque类模板的定义如下：<br><code>template &lt;class T, class Allocator = allocator&lt;T&gt;&gt; class deque;</code></p>
<p>二、deque的初始化：可以有五种方式，举例如下：<br>（1）<code>deque &lt;typename T&gt; name;</code>//创建容纳类型T的空deque容器对象<br>（2）<code>deque &lt;typename T&gt; name(size);</code>//创建初始大小为size的deque对象<br>（3）<code>deque &lt;typename T&gt; name(size, value);</code>//创建初始大小为size，每个元素初始值value的deque对象<br>（4）<code>deque &lt;typename T&gt; name(elsedeque);</code>//用复制构造函数从现有的deque型容器elsedeque中创建新的deque容器对象<br>（5）<code>deque &lt;typename T&gt; name(elsedeque.first(), elsedeque.end());</code>//使用迭代器创建deque容器对象</p>
<p>三、deque的基本应用函数<br>（1）<code>c.at(index);</code> //返回索引下标index所指的数据（从0开始）<br>（2）<code>c.front();</code> //返回第一个数据<br>（3）<code>c.back();</code>//返回最后一个数据<br>（4）<code>c.begin();</code> //返回指向第一个数据的迭代器<br>（5）<code>c.end();</code> //返回指向最后一个数据的下一个位置的迭代器<br>（6）<code>c.regin();</code> //返回逆向队列的第一个数据<br>（7）<code>c.rend();</code> //返回指向逆向队列的最后一个数据的下一个位置的迭代器<br>（8）<code>c.clear();</code> //销毁所有数据，释放内存<br>（9）<code>c.empty();</code> //判断容器是否为空<br>（10）<code>c.resize(n);</code>//deque队列的长度置为n，只保留队列前n个数<br>（11）<code>c.size();</code> //返回容器中实际数据的个数<br>（12）<code>swap(c1, c2);</code> //将c1和c2元素互换</p>
<p>四、deque的几种访问方式<br>（1）、向deque中添加元素<br>1、在尾部添加一个数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span> &lt;<span class="keyword">int</span>&gt; c;</span><br><span class="line">c.push_back(num); <span class="comment">//在容器尾部添加一个数据num</span></span><br></pre></td></tr></table></figure>
<p>2、在头部添加一个数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span> &lt;<span class="keyword">int</span>&gt; c;</span><br><span class="line">c.push_front(num); <span class="comment">//在容器头部添加一个数据num</span></span><br></pre></td></tr></table></figure>
<p>3、在pos前添加一个数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span> &lt;<span class="keyword">int</span>&gt; c;</span><br><span class="line">c.insert(pos, num); <span class="comment">//在该pos位置的数前面插入一个num</span></span><br></pre></td></tr></table></figure>
<p>4、在pos前添加n个相同数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span> &lt;<span class="keyword">int</span>&gt; c;</span><br><span class="line">c.insert(pos, n, num); <span class="comment">//在该pos位置的数前面插入n个num</span></span><br></pre></td></tr></table></figure>
<p>5、在pos前添加一个区间的数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span> &lt;<span class="keyword">int</span>&gt; c;</span><br><span class="line">c.insert(pos, beg, <span class="built_in">end</span>); <span class="comment">//在该pos位置的数前插入在[beg,end)区间的数据</span></span><br></pre></td></tr></table></figure>

<p>（2）、删除deque中的元素<br>1、删除最后一个元素</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span> &lt;<span class="keyword">int</span>&gt; c;</span><br><span class="line">c.push_front(<span class="number">1</span>);</span><br><span class="line">c.push_front(<span class="number">2</span>);</span><br><span class="line">c.pop_back();<span class="comment">//删除最后一个数据</span></span><br></pre></td></tr></table></figure>
<p>2、删除头部数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span> &lt;<span class="keyword">int</span>&gt; c;</span><br><span class="line">c.push_front(<span class="number">1</span>);</span><br><span class="line">c.push_front(<span class="number">2</span>);</span><br><span class="line">c.pop_front();<span class="comment">//删除头部数据</span></span><br></pre></td></tr></table></figure>
<p>3、删除pos位置的数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span> &lt;<span class="keyword">int</span>&gt; c;</span><br><span class="line">c.push_front(<span class="number">1</span>);</span><br><span class="line">c.push_front(<span class="number">2</span>);</span><br><span class="line">c.erase(pos); <span class="comment">//删除pos位置的数据</span></span><br></pre></td></tr></table></figure>
<p>4、删除[beg, end)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span> &lt;<span class="keyword">int</span>&gt; c;</span><br><span class="line">c.push_front(<span class="number">1</span>);</span><br><span class="line">c.push_front(<span class="number">2</span>);</span><br><span class="line">c.erase(beg, <span class="built_in">end</span>);<span class="comment">//删除[beg, end)区间的数据</span></span><br></pre></td></tr></table></figure>
<p><font color = red size = 6>关联式容器</font></p>
<p><font color = red size = 4>set的用法</font><br>set型容器能顺序存储一组数值，这些数值既充当存储的数据，又充当数据的键值。该集合更像一个有序链表，其中的元素以升序顺序存储。<br>要使用set，则必须要包含<a href="https://baike.baidu.com/item/set/2306085" target="_blank" rel="noopener">set头文件</a><br><code>#include &lt;set&gt;</code><br>一、头文件中，set类模板的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;c;assKey, <span class="class"><span class="keyword">class</span> <span class="title">Traits</span> = <span class="title">less</span>&lt;Key&gt;, <span class="title">class</span> <span class="title">Allocator</span> = <span class="title">allocator</span>&lt;Key&gt;&gt; <span class="title">class</span> <span class="title">set</span>;</span></span><br></pre></td></tr></table></figure>
<p>二、set的初始化：<br><code>set&lt;int &gt; s;</code>//创建一个空的set对象</p>
<p>三、set的基本应用函数<br>（1）<code>s.begin();</code>//返回指向第一个元素的迭代器<br>（2）<code>s.clear();</code>//清除所有元素<br>（3）<code>s.count();</code>//返回某个值元素的个数<br>（4）<code>s.empty();</code>//如果集合为空，返回true<br>（5）<code>s.end();</code>//返回指向最后一个元素的迭代器<br>（6）<code>s.erase();</code>//删除集合中的元素<br>（7）<code>s.find();</code>//返回一个指向被查找到元素的迭代器<br>（8）<code>s.insert();</code>//在集合中插入元素<br>（9）<code>s.lower_bound()</code>//返回指向大于（或等于）某值的第一个元素的迭代器<br>（10）<code>s.key_comp();</code>//返回一个用于元素间值比较的函数<br>（11）<code>s.max_size();</code>返回集合能容纳的元素的最大限值<br>（12）<code>s.rbegin();</code>//返回指向集合中最后一个元素的反向迭代器<br>（13）<code>s.rend();</code>//返回指向集合中第一个元素的反向迭代器<br>（14）<code>s.size();</code>//集合中元素的数目</p>
<p><font color = red size = 4>map的用法</font><br>map型容器是（键-值）对的集合。map型容器通常可理解为关联数组，可使用键作为下标来获取对应的值，类似于内置数组类型。在STL中，要使用map，则必须要包含<a href="https://baike.baidu.com/item/STL%20map/874674" target="_blank" rel="noopener">map头文件：</a><br><code>#include &lt;map&gt;</code><br>一、头文件中，set类模板的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Compare</span> = <span class="title">less</span> &lt;Key&gt;, <span class="title">class</span> <span class="title">Allocator</span> = <span class="title">allocator</span> &lt;pair&lt;const Key, T&gt;&gt;&gt; <span class="title">class</span> <span class="title">map</span>;</span></span><br></pre></td></tr></table></figure>
<p>二、map的初始化：可以又三种方式，举例如下:<br>（1）<code>map&lt;k, v&gt; m;</code> //创建一个名为m的空map对象，其键和值得类型分别为k和v<br>（2）<code>map&lt;k, v&gt; m(m1);</code> //创建m1的副本m，m与m1必须又相同的键类型和值类型<br>（3）<code>map&lt;k, v&gt; m(b, e);</code>//创建map类型的对象m，存储迭代器b和e标记的范围内所有元素的副本。元素的类型必须能转换成pair&lt;const k, v&gt;</p>
<p>三、map的基本应用函数<br>（1）<code>m.begin();</code>//返回指向map头部的迭代器<br>（2）<code>m.clear();</code>//删除所有元素<br>（3）<code>m.count();</code>//返回指定元素出现的次数<br>（4）<code>m.empty();</code>//如果map为空则返回true<br>（5）<code>m.end();</code>//返回指向map末尾的迭代器<br>（6）<code>m.erase();</code>//删除一个元素<br>（7）<code>m.find();</code>//查找一个元素<br>（8）<code>m.insert();</code>//插入元素<br>（9）<code>m.key_comp();</code>//返回比较元素key的函数<br>（10）<code>m.lower_bound();</code>//返回键值&gt;=给定元素的第一个位置<br>（11）<code>m.max_size();</code>//返回可以容纳的最大元素个数<br>（12）<code>m.rbegin();</code>//返回一个指向map尾部的逆向迭代器<br>（13）<code>m.rend();</code>//返回一个指向map头部的逆向迭代器<br>（14）<code>m.size();</code>//返回map中元素的个数<br>（15）<code>m.upper_bound();</code>//返回键值&gt;给定元素的第一个位置</p>
<p><font color = red size = 6>特殊容器用法</font></p>
<p><font color = red size = 4>stack的用法</font><br>stack类可以实例化一个栈容器（后进先出，LIFO）或栈对象。在STL中，要使用stack，则必须要包含<a href="https://baike.baidu.com/item/Stack/411907?fr=aladdin" target="_blank" rel="noopener">stack头文件：</a><br><code>#include &lt;stack&gt;</code><br>一、头文件中，stack类模板的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">namesapce <span class="built_in">std</span>&#123;<span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Container</span> = <span class="title">deque</span>&lt;T&gt;&gt; <span class="title">class</span> <span class="title">stack</span>;</span> &#125;</span><br></pre></td></tr></table></figure>
<p>二、stack的初始化：可以有两种方式，举例如下：<br>（1）<code>stack&lt;int&gt; s;</code>//创建一个空的stack对象。<br>（2）<code>stack &lt;int, list&lt;int&gt;&gt; s1;</code><br>         　　　<code>satck&lt;int , list&lt;int&gt;&gt; s2(s1);</code> //创建一个以双向链表为底层容器的空栈对象s2<br>三、stack的基本应用函数<br>（1）<code>a.push(b);</code>//将元素b压到栈顶<br>（2）<code>a.pop();</code>//将栈顶元素弹出<br>（3）<code>b = a.top();</code> //读取栈顶元素，并赋值给b<br>（4）<code>a.size();</code>//返回栈内元素个数<br>（5）<code>a.empty();</code> //判断栈是否为空，栈空返回true，栈非空返回false</p>
<p>四、stack的几种访问方式<br>（1）、向栈中添加元素</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span> &lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">a.push(b); <span class="comment">////将元素b压到栈顶</span></span><br></pre></td></tr></table></figure>
<p>（2）、删除栈顶元素</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">a.push(b);</span><br><span class="line">a.push(c);</span><br><span class="line"><span class="keyword">while</span>(!a.empty())  <span class="comment">//判断栈是否为空</span></span><br><span class="line">	a.pop();     <span class="comment">//将栈顶元素删除</span></span><br></pre></td></tr></table></figure>
<p><font color = "red">　　堆栈是一种应用非常广泛的数据结构。C++STL将这种数据结构和它若干受限制操作用泛型类stack容器封装起来，包括堆栈初始化、元素入栈、取栈顶元素、元素出栈、判断堆栈是否非空和取得当前堆栈大小等，应用起来十分容易。</font></p>
<p><font color = red size = 4>queue的用法</font><br>queue类模板可以实例化队列容器（先进先出， FIFO）。queue是双端口的，元素压入时是从一端，元素移除时是从另一端。通俗来讲，queue是典型的数据缓冲区结构。在STL中，要使用queue，则必须要包含<a href="https://baike.baidu.com/item/queue/4511093" target="_blank" rel="noopener">queue头文件：</a><br><code>#include &lt;queue&gt;</code><br>一、头文件中，queue类模板的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">namesapce <span class="built_in">std</span>&#123;<span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Container</span> = <span class="title">deque</span>&lt;T&gt;&gt; <span class="title">class</span> <span class="title">queue</span>;</span> &#125;</span><br></pre></td></tr></table></figure>
<p>二、queue的初始化<br><code>queue&lt;int&gt; a;</code> //创建一个int型的队列（尖括号中为元素类型名，它可以是任何合法的数据类型）</p>
<p>三、queue的基本应用函数<br>（1）<code>a.back();</code>//返回一个引用，返回队列的最后一个元素。<br>（2）<code>a.empty();</code>//函数返回真(true)如果队列为空，否则返回假(false)。<br>（3）<code>a.front();</code>//返回队列第一个元素的引用。<br>（4）<code>a.pop();</code>//函数删除队列的一个元素<br>（5）<code>a.push();</code>//在末尾加入一个元素<br>（6）<code>a.size();</code> //返回队列中元素的个数</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://ccliangliang.github.io/2020/02/25/C++%20container/" data-id="ck7alpw2o0000c0vvfj5fhmhl" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/STL/" rel="tag">STL</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/03/02/Euler's%20totient%20function/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          Euler&#39;s totient function
        
      </div>
    </a>
  
  
    <a href="/2020/02/25/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>



</section>
        
          <aside id="sidebar">
  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <h1 class="blog-title">Misakas</h1>
    <h2 class="blog-subtitle"></h2>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/categories" title="Categories">
            <li>分类</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>标签</li>
          </a>
        
    </ul>
  </div>
</div>

  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1582606800301&amp;di=836da10f5415c3117c4449e1b4e818d2&amp;imgtype=0&amp;src=http%3A%2F%2Fimg.qqzhi.com%2Fuploads%2F2018-12-22%2F094255544.jpg">
    <h2 class="author">Misakas</h2>
    <h3 class="description"></h3>
    <div class="count-box">
      <a href="/archives"><div><strong>4</strong><br>文章</div></a>
      <a href="/categories"><div><strong>2</strong><br>分类</div></a>
      <a href="/tags"><div><strong>4</strong><br>标签</div></a>
    </div>



    <div class="social-link">
      
        <a class="hvr-bounce-in" href="https://github.com/ccliangliang" target="_blank" title="Misaka&#39;s">
          Misaka&#39;s
        </a>
      
    </div>

    <div class="friend-link">
      <h2>友情链接</h2>
      
        <a class="hvr-bounce-in" href="http://blog.shanamaid.top/" target="_blank" title="ShanaMaid">
          ShanaMaid
        </a>
      
    </div>
  </div>
</div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy;2019 - 2020 Misakas<br>
      由<a href="http://hexo.io/" target="_blank">Hexo</a>强力驱动 | 
      主题-<a href="https://github.com/ShanaMaid/hexo-theme-shana" target="_blank" rel="noopener">Shana</a>
      
        |<script src="http://s11.cnzz.com/z_stat.php?id=1278636342&web_id=1278636342" language="JavaScript"></script>
      
    </div>
    
  </div>
</footer>
    </div>
    

<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script src="//apps.bdimg.com/libs/wow/0.1.6/wow.min.js"></script>
<script>
new WOW().init();
</script>   


  
<link rel="stylesheet" href="/plugin/fancybox/jquery.fancybox.css">

  
<script src="/plugin/fancybox/jquery.fancybox.pack.js"></script>




  <section class="hidden-xs"> 
  <ul class="cb-slideshow"> 
    <li><span>苟利</span></li> 
    <li><span>国家</span></li> 
    <li><span>生死以</span></li> 
    <li><span>岂能</span></li> 
    <li><span>祸福</span></li> 
    <li><span>趋避之</span></li> 
  </ul>
</section>

<script src="/js/script.js"></script>





  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("nDImrqai2dqSbTKT7uLR3WLo-gzGzoHsz", "O2wPGSNgLQEYYYASyVtCwMO4");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.article-title').length > 1) {
        showTime(Counter);
      }
    });
  </script>





  </div>

  <!-- 页面点击小红心，在末尾添加，避免找不到 -->
<script type="text/javascript" src="/js/love.js"></script>
</body>
</html>